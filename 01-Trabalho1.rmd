---
title: "SME0821 - Análise de Sobrevivência - Atividade I"
author: 
  - Francisco Rosa Dias de Miranda - 4402962
  - Heitor Carvalho Pinheiro - 11833351
  - Lua
  - Victor
  - Gusthavo
date: "abril 2022"
output: pdf_document
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1) Introdução

aqui pode descrever os dados e fonte de onde foi obtida (os dados podem vir de artigos, DATASUS, FOSP, HOSPITAIS, ESTUDOS PLANEJADOS, ETC), assim como os objetivos especificos do estudo.


 
```{r include=FALSE}
library(tidyverse)
library(survival)
library(survminer)
```

Conjunto de dados utilizado

```{r}
df <- survminer::myeloma
```

## **Multiple Myeloma Data**

### Description
Multiple Myeloma data extracted from publicly available gene expression data (GEO Id: GSE4581).

Usage
data("myeloma")

**Format**
A data frame with 256 rows and 12 columns.

#### **Variables**

* molecular_group
Patients' molecular subgroups

* chr1q21_status
Amplification status of the chromosome 1q21

* treatment
All patients were assigned to a TT2 (Total Therapy 2) treatment

* event
survival status 0 = alive, 1 = dead

* time
Survival time in months

* CCND1
Gene expression

* CRIM1
Gene expression

* DEPDC1
Gene expression

* IRF4
Gene expression

* TP53
Gene expression

* WHSC1
Gene expression

The remaining columns (CCND1, CRIM1, DEPDC1, IRF4, TP53, WHSC1) correspond to the gene expression level of specified genes.


# 2) Metodologia: Uma breve descrição da metodologia;

metodologia não paramétrica a dados  de sobrevivência em presença de censura 


# 3) Análise de dados 

 - K-M
 - Atuarial 
 - Nelson-Aalen
 - EMV
 - Newton-Rapson
 - Testes de hipotese
 
 ###############################################################
 
 I) *K-M Algoritmo*
 
```{r}
km_fit <- survfit(Surv(df$time, df$event) ~ 1)
```
 
```{r}
ggsurvplot(km_fit, data = df, risk.table = FALSE)
```

```{r}
summary_table <- summary(km_fit, times = c(0,1:70))
summary_table
```
 
##### Determining the optimal cutpoint for each gene expression

```{r}
res.cut <- surv_cutpoint(df, time = "time", event = "event",
                         variables = c("CRIM1", "DEPDC1", "WHSC1",
                                       "CCND1", "IRF4", "TP53"))

summary(res.cut)
```

Plot of each cutpoint

```{r}
genes <- c("CCND1", "CRIM1","DEPDC1", "IRF4", "TP53", "WHSC1")

#plotando a distribuicao de cada gene

for(gene in genes){
  print(plot(res.cut, gene, pallete = "npg"))
}

# plot(res.cut, "CRIM1", pallete = "npg")



```

Categorizing the variables

```{r}
res.cat <- surv_categorize(res.cut)
head(res.cat)
```

##### Fitting Survival Curves for each gene expression

```{r}
#defyning each fit for each gene

fit1 <- survfit(Surv(time, event) ~ CCND1, data = res.cat)
fit2 <- survfit(Surv(time, event) ~ CRIM1, data = res.cat)
fit3 <- survfit(Surv(time, event) ~ DEPDC1, data = res.cat)
fit4 <- survfit(Surv(time, event) ~ IRF4, data = res.cat)
fit5 <- survfit(Surv(time, event) ~ TP53, data = res.cat)
fit6 <- survfit(Surv(time, event) ~ WHSC1, data = res.cat)


#List of ggsurvplots
splots <- list()

splots[[1]] <- ggsurvplot(fit1, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())
splots[[2]] <- ggsurvplot(fit2, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())
splots[[3]] <- ggsurvplot(fit3, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())
splots[[4]] <- ggsurvplot(fit4, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())
splots[[5]] <- ggsurvplot(fit5, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())
splots[[6]] <- ggsurvplot(fit6, data = df, risk.table = TRUE, risk.table.height = 0.3,
                          ggtheme = theme_minimal())

#arrange multiple ggsurvplots
arrange_ggsurvplots(splots, print = TRUE, 
                    ncol = 3, nrow = 2)

if (TRUE) {
# Arrange and save into pdf file
res <- arrange_ggsurvplots(splots, print = FALSE)
ggsave("myfile.pdf", res)
}
```


##### Comparando múltiplas curvas de sobrevivência para os diferentes grupos moleculares

```{r}
# Survival curves with global p-value
fit2 <- survfit(Surv(time, event) ~ molecular_group, data = df)
ggsurvplot(fit2, data = myeloma,
           legend.title = "Grupos Moleculares",
           legend.labs = levels(myeloma$molecular_group),
           legend = "right",
           pval = TRUE, palette = "lancet")

# summary(fit2)
```

O gráfico acima expõe todas as curvas de sobrevivência para os diferentes grupos moleculares. 

Em nosso teste de hipótese temos duas hipóteses possíveis:

$H_0:$ Não há diferença entre as curvas de sobrevivência para os diferentes grupos moleculares.
$H_1$ Há diferença entre as curvas de sobrevivência para os diferentes grupos moleculares.

Em nosso teste, utilizamos por padrão um $\alpha = 0.05$, ou seja, nosso Intervalo de Confiança é de 95%. 

O valor-p resposta é um valor global que apenas nos indica se há alguma diferença entre as curvas de sobrevivência. Como $p = 0.047 < 0.05$, podemos rejeitar $H_0$ e concluir que existe uma diferença entre os grupos moleculares.

Podemos realizar um Log-rank teste pareado entre os diferentes grupos moleculares, a fim de identificar quais grupos apresentam diferenças significativas de risco de morte.

```{r}
# Pairwise survdiff
res <- pairwise_survdiff(Surv(time, event) ~ molecular_group,
     data = myeloma)
res
```
De acordo com o teste Log-Rank entre os grupos moleculares, podemos concluir que existe diferença significativa entre os seguintes grupos moleculares:

* Proliferation e Cyclin D-2
* Proliferation e Hyperdiploid


# 4) Bibliográfia


```{r}
citation("survminer")
```


# 5) Uma pasta com os dados e codigos para que o trabalho seja reproduzidos.

# 6) Os grupos apresentaram os resultados em sala de aula.


### Codigos que o prof passou


```{r}

tempo=c(3,4,5.7,6.5,6.5,8.4,10,10,12,15)
censura=c(1,0,0,1,1,0,1,0,1,1)
mKM = survfit(Surv(tempo, censura) ~ 1, se.fit = FALSE)
summary(mKM)
```
```{r}
plot(mKM, mark.time=T, xlab = "Tempo", ylab = "Função de Sobrevivência", cex.axis = 1.5, cex.lab = 1.5)
```


## Aula 22-05

```{r}
t=c(3.1, 6.8, 9.0, 9.0, 11.3, 16.2, 8.7, 9.0 ,10.1, 12.1, 18.3,23.1)
d=c(1, 0 ,1, 1, 0, 1, 1, 1, 0, 0 ,1, 0)
grupo=c(1,1,1,1,1,1,2,2,2,2,2,2)
fit=survdiff( Surv(t,d)~grupo)
fit
```
```{r}
library(KMsurv)
data(drug6mp)
drug6mp[1:7, ]

time=c(drug6mp$t1,drug6mp$t2)
irelapse=c(rep(1,21),drug6mp$relapse)
grupo=c(rep(1,21),rep(2,21))
fit=survdiff( Surv( time, irelapse )~grupo)
```

```{r}

library(survminer)

ggsurvplot(mKM,
            pval = TRUE,
            xlab = "Tempo em meses",
            ylab="Funçao de sobrevivencia",
            break.time.by = 2,
            risk.table = "abs_pct", # indivı́duos em risco.
            surv.median.line = "hv", # sobrevivencia mediana,
            legend.labs = levels(as.factor(larynx$stage) ))
```

```{r}
res <- pairwise_survdiff(Surv(time,delta)~stage,data=larynx,
                  p.adjust.method = "none")
res
```

```{r}
ggsurvplot_facet(fit0,dad, facet.by = "idade",
palette = "jco", surv.median.line = "hv",pval = TRUE)
```



aula 21-06

```{r}
U_alpha=function(vpar,t){
alpha=vpar[1]
n=length(t)
lambda=n/sum(t^alpha)
U1=n/alpha-lambda*sum(t^alpha*log(t))+sum(log(t))
U1
}
## uniroot: determina o zero de uma funçao
alpha_m <- uniroot(U_alpha, interval=c(0.0000,20), tol = 0)
lambda_m=length(t)/sum(t^alpha_m)
EMV=c(alpha_m,lambda_m)
U(vpar)
```


```{r}
## Matriz de Informaçao observada
I=function(vpar){
alpha=vpar[1]
lambda=vpar[2]
n=length(t)
I11=n/alpha^2+lambda*sum(t^alpha*(log(t))^2)
I12=sum((t^alpha*log(t)))
I22=n/lambda^2
I=matrix(c(I11,I12,I12,I22),2,2)
}
```

```{r}
# Vetor escore
U=function(vpar){
alpha=vpar[1]
lambda=vpar[2]
n=length(t)
U1=n/alpha-lambda*sum((t^alpha)*log(t))+sum(log(t))
U2=n/lambda-sum(t^alpha)
U=rbind(U1,U2)
U
}
# A funçao de verossimilhança
like=function(vpar){
alpha=(vpar[1])
lambda=(vpar[2])
n=length(t)
vf=alpha*lambda*t^(alpha-1)*exp(-lambda*t^alpha)
like=sum(log(vf))
like
}
```

```{r}
N_R=function(vpar,nmax=300, stoptol=0.0000001){
  iter = 0
  newpar = vpar
  oldpar = vpar+ 0.1
  while(iter < nmax & sqrt(sum((newpar - oldpar)^2)) >stoptol) {
    oldpar = newpar
    newpar = oldpar+solve(I(oldpar))%*%U(oldpar)
    iter = iter + 1
    print(iter)
    list(par=newpar, fun=like(newpar), COV=I(newpar))
  }
  saida=list(par=newpar, fun=like(newpar), SCORE=U(newpar))
  saida
}
NR=N_R(vpar)
```


```{r}
emv=fit1$icoef # estimativas de mu and log sigma
mu=emv[1]
sigma=exp(emv[2])
alpha=1/sigma
lambda=exp(-mu/sigma)
mv=c(alpha,lambda)
cov1=fit1$var #Matriz variância e covariância da EMV de mu and log sigma
```

```{r}
library(msm)
EP=deltamethod(list( 1/exp(x2), exp(-x1/exp(x2))), emv, cov1)
LI=mv-1.96*EP
LS=mv+1.96*EP
Est=cbind(mv,dm,LI, LS)
rownames(Est)=c("Alpha","Lambda")
colnames(Est)=c("EMV","EP","LI","LS")
print(round(Est,5))
```

